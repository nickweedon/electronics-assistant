#!/usr/bin/env node

/**
 * AliExpress Orders - Extract order list from AliExpress
 * Generated by Playwright skill
 *
 * Parameters:
 * - url: Orders page URL (default: https://www.aliexpress.com/p/order/index.html)
 * - headless: Run in headless mode (default: false for debugging)
 * - timeout: Page timeout in ms (default: 15000)
 */

const playwright = require('playwright-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const fs = require('fs');
const path = require('path');

// Apply stealth plugin
playwright.chromium.use(StealthPlugin());

// Parse command line arguments
const args = {};
process.argv.slice(2).forEach(arg => {
  const [key, value] = arg.replace('--', '').split('=');
  args[key] = value;
});

const targetUrl = args.url || 'https://www.aliexpress.com/p/order/index.html';
const waitForSelector = args.waitFor || null;
const fullPage = args.fullPage !== 'false';
const screenshotPath = args.output || `./screenshots/aliexpress-orders-${Date.now()}.png`;

// Configuration
const config = {
  headless: args.headless === 'true', // Default to visible mode for debugging
  timeout: parseInt(args.timeout) || 15000, // Longer timeout for AliExpress
  screenshotDir: './screenshots',
  viewport: { width: parseInt(args.width) || 1920, height: parseInt(args.height) || 1080 }
};

// Ensure screenshot directory exists
const screenshotDir = path.dirname(screenshotPath);
if (!fs.existsSync(screenshotDir)) {
  fs.mkdirSync(screenshotDir, { recursive: true });
}

/**
 * Main execution function
 */
async function main() {
  const startTime = Date.now();
  let browser = null;
  let context = null;
  let page = null;

  try {
    console.error(`[INFO] Navigating to: ${targetUrl}`);

    // Launch browser with stealth
    browser = await playwright.chromium.launch({
      headless: config.headless,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-blink-features=AutomationControlled'
      ]
    });

    // Create context with realistic settings
    context = await browser.newContext({
      viewport: config.viewport,
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      locale: 'en-US',
      timezoneId: 'America/New_York',
      permissions: [],
      extraHTTPHeaders: {
        'Accept-Language': 'en-US,en;q=0.9'
      }
    });

    page = await context.newPage();
    page.setDefaultTimeout(config.timeout);

    // Navigate to URL
    await page.goto(targetUrl, {
      waitUntil: 'domcontentloaded',
      timeout: config.timeout
    });

    await page.waitForLoadState('domcontentloaded');
    console.error('[INFO] Page loaded');

    // Wait for specific selector if provided
    if (waitForSelector) {
      console.error(`[INFO] Waiting for selector: ${waitForSelector}`);
      await page.waitForSelector(waitForSelector, {
        state: 'visible',
        timeout: config.timeout
      });
      console.error('[INFO] Selector found');
    }

    // Wait for orders to load - try multiple possible selectors
    console.error('[INFO] Waiting for orders to load...');
    await page.waitForTimeout(3000); // Give time for SPA to initialize

    // Try to detect if we need to login
    const needsLogin = await page.evaluate(() => {
      const loginIndicators = [
        'login', 'sign in', 'sign-in', 'signin',
        'Log in', 'Sign In', 'Sign in'
      ];
      const pageText = document.body.innerText.toLowerCase();
      return loginIndicators.some(indicator => pageText.includes(indicator.toLowerCase()));
    });

    if (needsLogin) {
      console.error('[WARN] Login may be required - page contains login indicators');
    }

    // Extract order data
    const pageData = await page.evaluate(() => {
      const orders = [];

      // Try multiple possible selectors for order items
      const possibleSelectors = [
        '.order-item',
        '.order-list-item',
        '.comet-order-item',
        '[class*="order"]',
        '[class*="Order"]'
      ];

      let orderElements = [];
      for (const selector of possibleSelectors) {
        orderElements = Array.from(document.querySelectorAll(selector));
        if (orderElements.length > 0) {
          console.log(`Found ${orderElements.length} orders using selector: ${selector}`);
          break;
        }
      }

      // Extract order information
      orderElements.forEach((el, index) => {
        try {
          const order = {
            index: index + 1,
            text: el.innerText.trim().substring(0, 500), // First 500 chars
            html: el.innerHTML.substring(0, 1000) // First 1000 chars of HTML
          };

          // Try to extract specific fields
          const orderNumber = el.querySelector('[class*="order-number"], [class*="orderId"]');
          if (orderNumber) order.orderNumber = orderNumber.innerText.trim();

          const orderDate = el.querySelector('[class*="date"], [class*="Date"]');
          if (orderDate) order.date = orderDate.innerText.trim();

          const orderStatus = el.querySelector('[class*="status"], [class*="Status"]');
          if (orderStatus) order.status = orderStatus.innerText.trim();

          const orderPrice = el.querySelector('[class*="price"], [class*="Price"], [class*="amount"]');
          if (orderPrice) order.price = orderPrice.innerText.trim();

          orders.push(order);
        } catch (e) {
          console.error(`Error extracting order ${index}: ${e.message}`);
        }
      });

      return {
        title: document.title,
        url: window.location.href,
        orderCount: orders.length,
        orders: orders,
        // Get some general page info for debugging
        bodyText: document.body.innerText.substring(0, 2000), // First 2000 chars of page text
        headings: Array.from(document.querySelectorAll('h1, h2, h3')).map(h => ({
          tag: h.tagName,
          text: h.textContent.trim()
        })).slice(0, 10)
      };
    });

    console.error(`[INFO] Page title: ${pageData.title}`);
    console.error(`[INFO] Found ${pageData.orderCount} orders`);

    // Take screenshot
    console.error(`[INFO] Capturing screenshot...`);
    await page.screenshot({
      path: screenshotPath,
      fullPage: fullPage,
      type: 'png'
    });

    console.error(`[INFO] Screenshot saved: ${screenshotPath}`);

    // Order data already extracted above

    const duration = Date.now() - startTime;

    // Output structured JSON result
    const result = {
      success: true,
      data: {
        ...pageData,
        screenshotPath: screenshotPath
      },
      metadata: {
        url: page.url(),
        timestamp: new Date().toISOString(),
        duration: duration,
        browser: 'chromium',
        screenshots: [screenshotPath]
      }
    };

    console.log(JSON.stringify(result, null, 2));

  } catch (error) {
    console.error(`[ERROR] ${error.message}`);

    let errorScreenshotPath = null;

    // Take screenshot on error
    if (page) {
      try {
        errorScreenshotPath = path.join(
          config.screenshotDir,
          `error-${Date.now()}.png`
        );
        if (!fs.existsSync(config.screenshotDir)) {
          fs.mkdirSync(config.screenshotDir, { recursive: true });
        }
        await page.screenshot({
          path: errorScreenshotPath,
          fullPage: true
        });
        console.error(`[INFO] Error screenshot saved: ${errorScreenshotPath}`);
      } catch (screenshotError) {
        console.error(`[WARN] Failed to capture screenshot: ${screenshotError.message}`);
      }
    }

    const duration = Date.now() - startTime;

    // Output error as JSON
    const errorResult = {
      success: false,
      data: null,
      metadata: {
        url: page ? page.url() : targetUrl,
        timestamp: new Date().toISOString(),
        duration: duration,
        browser: 'chromium'
      },
      error: {
        message: error.message,
        stack: error.stack,
        screenshot: errorScreenshotPath
      }
    };

    console.log(JSON.stringify(errorResult, null, 2));
    process.exit(1);

  } finally {
    // Cleanup
    if (context) {
      await context.close();
    }
    if (browser) {
      await browser.close();
    }
    console.error('[INFO] Browser closed');
  }
}

// Run main function
main().catch(error => {
  console.error(`[FATAL] ${error.message}`);
  process.exit(1);
});
