#!/usr/bin/env node

/**
 * AliExpress Orders - Extract order list from AliExpress
 * Generated by Playwright skill
 *
 * Parameters:
 * - url: Orders page URL (default: https://www.aliexpress.com/p/order/index.html)
 * - headless: Run in headless mode (default: false for debugging)
 * - timeout: Page timeout in ms (default: 15000)
 */

const playwright = require('playwright-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const fs = require('fs');
const path = require('path');

// Apply stealth plugin
playwright.chromium.use(StealthPlugin());

// Parse command line arguments
const args = {};
process.argv.slice(2).forEach(arg => {
  const [key, value] = arg.replace('--', '').split('=');
  args[key] = value;
});

const targetUrl = args.url || 'https://www.aliexpress.com/p/order/index.html';
const waitForSelector = args.waitFor || null;
const fullPage = args.fullPage !== 'false';
const screenshotPath = args.output || `./screenshots/aliexpress-orders-${Date.now()}.png`;

// Configuration
const config = {
  headless: args.headless === 'true', // Default to visible mode for debugging
  timeout: parseInt(args.timeout) || 15000, // Longer timeout for AliExpress
  screenshotDir: './screenshots',
  viewport: { width: parseInt(args.width) || 1920, height: parseInt(args.height) || 1080 },
  manual: args.manual === 'true', // Manual mode - keeps browser open for login
  pause: parseInt(args.pause) || 0 // Pause time in seconds before closing (for manual interaction)
};

// Ensure screenshot directory exists
const screenshotDir = path.dirname(screenshotPath);
if (!fs.existsSync(screenshotDir)) {
  fs.mkdirSync(screenshotDir, { recursive: true });
}

/**
 * Main execution function
 */
async function main() {
  const startTime = Date.now();
  let context = null;
  let page = null;

  try {
    console.error(`[INFO] Navigating to: ${targetUrl}`);

    // Use persistent context to save login sessions
    // Use the mounted Docker volume for browser profiles
    const userDataDir = path.join(process.env.HOME || '/home/vscode', '.cache/playwright-profiles/aliexpress');

    // Launch browser with persistent context
    context = await playwright.chromium.launchPersistentContext(userDataDir, {
      headless: config.headless,
      viewport: config.viewport,
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      locale: 'en-US',
      timezoneId: 'America/New_York',
      permissions: [],
      extraHTTPHeaders: {
        'Accept-Language': 'en-US,en;q=0.9'
      },
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-blink-features=AutomationControlled',
        '--disable-session-crashed-bubble',
        '--hide-crash-restore-bubble',
        '--disable-infobars',
        '--no-first-run',
        '--noerrors',
        '--disable-popup-blocking'
      ]
    });

    // Get existing page or create new one
    const pages = context.pages();
    page = pages.length > 0 ? pages[0] : await context.newPage();
    page.setDefaultTimeout(config.timeout);

    // Navigate to URL
    await page.goto(targetUrl, {
      waitUntil: 'domcontentloaded',
      timeout: config.timeout
    });

    await page.waitForLoadState('domcontentloaded');
    console.error('[INFO] Page loaded');

    // Wait for specific selector if provided
    if (waitForSelector) {
      console.error(`[INFO] Waiting for selector: ${waitForSelector}`);
      await page.waitForSelector(waitForSelector, {
        state: 'visible',
        timeout: config.timeout
      });
      console.error('[INFO] Selector found');
    }

    // Wait for orders to load - try multiple possible selectors
    console.error('[INFO] Waiting for orders to load...');
    await page.waitForTimeout(3000); // Give time for SPA to initialize

    // Try to detect if we need to login
    const currentUrl = page.url();
    const urlNeedsLogin = currentUrl.includes('login') ||
                          currentUrl.includes('signin') ||
                          currentUrl.includes('sign-in') ||
                          currentUrl.includes('accounts.google.com');

    const needsLogin = urlNeedsLogin || await page.evaluate(() => {
      const loginIndicators = [
        'login', 'sign in', 'sign-in', 'signin',
        'Log in', 'Sign In', 'Sign in'
      ];
      const pageText = document.body.innerText.toLowerCase();
      return loginIndicators.some(indicator => pageText.includes(indicator.toLowerCase()));
    });

    if (needsLogin) {
      console.error('[WARN] Login may be required - page contains login indicators');

      if (config.manual) {
        console.error('[INFO] Manual mode enabled - waiting for you to complete login...');
        console.error('[INFO] Please log in to AliExpress in the browser window');
        console.error('[INFO] The script will wait for up to 5 minutes...');

        // Wait for successful login by checking multiple indicators
        const loginTimeout = 300000; // 5 minutes
        const startWait = Date.now();

        while ((Date.now() - startWait < loginTimeout)) {
          const currentUrl = page.url();

          // Check if we've successfully logged in (don't assume we're on orders page)
          const isOnAliExpress = currentUrl.includes('aliexpress.com') || currentUrl.includes('aliexpress.us');
          const isNotAuthPage = !currentUrl.includes('login') &&
                                !currentUrl.includes('signin') &&
                                !currentUrl.includes('accounts.google.com') &&
                                !currentUrl.includes('thirdparty') &&
                                !currentUrl.includes('ggcallback');

          const pageTitle = await page.title().catch(() => '');

          const isLoggedIn = isOnAliExpress && isNotAuthPage;

          if (isLoggedIn) {
            console.error('[INFO] âœ“ Login successful - you are now on AliExpress!');
            console.error(`[INFO] Page title: ${pageTitle}`);
            console.error(`[INFO] Current URL: ${currentUrl}`);

            // Navigate back to orders page after login
            console.error('[INFO] Navigating to orders page...');
            await page.goto(targetUrl, {
              waitUntil: 'domcontentloaded',
              timeout: config.timeout
            });
            break;
          }

          console.error(`[DEBUG] Waiting for login... Title: "${pageTitle}", URL: ${currentUrl.substring(0, 60)}...`);
          await page.waitForTimeout(2000); // Check every 2 seconds
        }

        const finalUrl = page.url();
        if (Date.now() - startWait >= loginTimeout) {
          console.error(`[WARN] Timeout reached. Current URL: ${finalUrl}`);
        }

        console.error('[INFO] Waiting for page content to fully load...');
        await page.waitForTimeout(3000); // Give time for SPA to load
      }
    }

    // Extract order data
    const pageData = await page.evaluate(() => {
      const orders = [];

      // Try multiple possible selectors for order items
      const possibleSelectors = [
        '.order-item',
        '.order-list-item',
        '.comet-order-item',
        '[class*="order"]',
        '[class*="Order"]'
      ];

      let orderElements = [];
      for (const selector of possibleSelectors) {
        orderElements = Array.from(document.querySelectorAll(selector));
        if (orderElements.length > 0) {
          console.log(`Found ${orderElements.length} orders using selector: ${selector}`);
          break;
        }
      }

      // Extract order information
      orderElements.forEach((el, index) => {
        try {
          const order = {
            index: index + 1,
            text: el.innerText.trim().substring(0, 500), // First 500 chars
            html: el.innerHTML.substring(0, 1000) // First 1000 chars of HTML
          };

          // Try to extract specific fields
          const orderNumber = el.querySelector('[class*="order-number"], [class*="orderId"]');
          if (orderNumber) order.orderNumber = orderNumber.innerText.trim();

          const orderDate = el.querySelector('[class*="date"], [class*="Date"]');
          if (orderDate) order.date = orderDate.innerText.trim();

          const orderStatus = el.querySelector('[class*="status"], [class*="Status"]');
          if (orderStatus) order.status = orderStatus.innerText.trim();

          const orderPrice = el.querySelector('[class*="price"], [class*="Price"], [class*="amount"]');
          if (orderPrice) order.price = orderPrice.innerText.trim();

          orders.push(order);
        } catch (e) {
          console.error(`Error extracting order ${index}: ${e.message}`);
        }
      });

      return {
        title: document.title,
        url: window.location.href,
        orderCount: orders.length,
        orders: orders,
        // Get some general page info for debugging
        bodyText: document.body.innerText.substring(0, 2000), // First 2000 chars of page text
        headings: Array.from(document.querySelectorAll('h1, h2, h3')).map(h => ({
          tag: h.tagName,
          text: h.textContent.trim()
        })).slice(0, 10)
      };
    });

    console.error(`[INFO] Page title: ${pageData.title}`);
    console.error(`[INFO] Found ${pageData.orderCount} orders`);

    // Take screenshot
    console.error(`[INFO] Capturing screenshot...`);
    await page.screenshot({
      path: screenshotPath,
      fullPage: fullPage,
      type: 'png'
    });

    console.error(`[INFO] Screenshot saved: ${screenshotPath}`);

    // Order data already extracted above

    const duration = Date.now() - startTime;

    // Output structured JSON result
    const result = {
      success: true,
      data: {
        ...pageData,
        screenshotPath: screenshotPath
      },
      metadata: {
        url: page.url(),
        timestamp: new Date().toISOString(),
        duration: duration,
        browser: 'chromium',
        screenshots: [screenshotPath]
      }
    };

    console.log(JSON.stringify(result, null, 2));

    // Pause before closing if requested (for manual interaction)
    if (config.pause > 0) {
      console.error(`[INFO] Pausing for ${config.pause} seconds before closing...`);
      console.error('[INFO] You can interact with the browser during this time.');
      await page.waitForTimeout(config.pause * 1000);
    }

  } catch (error) {
    console.error(`[ERROR] ${error.message}`);

    let errorScreenshotPath = null;

    // Take screenshot on error
    if (page) {
      try {
        errorScreenshotPath = path.join(
          config.screenshotDir,
          `error-${Date.now()}.png`
        );
        if (!fs.existsSync(config.screenshotDir)) {
          fs.mkdirSync(config.screenshotDir, { recursive: true });
        }
        await page.screenshot({
          path: errorScreenshotPath,
          fullPage: true
        });
        console.error(`[INFO] Error screenshot saved: ${errorScreenshotPath}`);
      } catch (screenshotError) {
        console.error(`[WARN] Failed to capture screenshot: ${screenshotError.message}`);
      }
    }

    const duration = Date.now() - startTime;

    // Output error as JSON
    const errorResult = {
      success: false,
      data: null,
      metadata: {
        url: page ? page.url() : targetUrl,
        timestamp: new Date().toISOString(),
        duration: duration,
        browser: 'chromium'
      },
      error: {
        message: error.message,
        stack: error.stack,
        screenshot: errorScreenshotPath
      }
    };

    console.log(JSON.stringify(errorResult, null, 2));
    process.exit(1);

  } finally {
    // Cleanup
    if (context) {
      await context.close();
    }
    console.error('[INFO] Browser closed');
  }
}

// Run main function
main().catch(error => {
  console.error(`[FATAL] ${error.message}`);
  process.exit(1);
});
