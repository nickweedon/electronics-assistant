#!/usr/bin/env node

/**
 * {{actionName}} - Navigate and capture {{siteName}}
 * Generated by Playwright skill
 *
 * Parameters:
 * - url: Target URL to navigate (default: {{defaultUrl}})
 * - waitFor: Selector to wait for before capturing (optional)
 * - fullPage: Capture full page screenshot (default: true)
 */

const playwright = require('playwright-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const fs = require('fs');
const path = require('path');

// Apply stealth plugin
playwright.chromium.use(StealthPlugin());

// Parse command line arguments
const args = {};
process.argv.slice(2).forEach(arg => {
  const [key, value] = arg.replace('--', '').split('=');
  args[key] = value;
});

const targetUrl = args.url || '{{defaultUrl}}';
const waitForSelector = args.waitFor || null;
const fullPage = args.fullPage !== 'false';
const screenshotPath = args.output || `./screenshots/screenshot-${Date.now()}.png`;

// Configuration
const config = {
  headless: args.headless !== 'false',
  timeout: parseInt(args.timeout) || 5000,
  screenshotDir: './screenshots',
  viewport: { width: parseInt(args.width) || 1920, height: parseInt(args.height) || 1080 }
};

// Ensure screenshot directory exists
const screenshotDir = path.dirname(screenshotPath);
if (!fs.existsSync(screenshotDir)) {
  fs.mkdirSync(screenshotDir, { recursive: true });
}

/**
 * Main execution function
 */
async function main() {
  const startTime = Date.now();
  let browser = null;
  let context = null;
  let page = null;

  try {
    console.error(`[INFO] Navigating to: ${targetUrl}`);

    // Launch browser with stealth
    browser = await playwright.chromium.launch({
      headless: config.headless,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-blink-features=AutomationControlled'
      ]
    });

    // Create context with realistic settings
    context = await browser.newContext({
      viewport: config.viewport,
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      locale: 'en-US',
      timezoneId: 'America/New_York',
      permissions: [],
      extraHTTPHeaders: {
        'Accept-Language': 'en-US,en;q=0.9'
      }
    });

    page = await context.newPage();
    page.setDefaultTimeout(config.timeout);

    // Navigate to URL
    await page.goto(targetUrl, {
      waitUntil: 'domcontentloaded',
      timeout: config.timeout
    });

    await page.waitForLoadState('domcontentloaded');
    console.error('[INFO] Page loaded');

    // Wait for specific selector if provided
    if (waitForSelector) {
      console.error(`[INFO] Waiting for selector: ${waitForSelector}`);
      await page.waitForSelector(waitForSelector, {
        state: 'visible',
        timeout: config.timeout
      });
      console.error('[INFO] Selector found');
    }

    // Wait a bit for any animations or dynamic content
    await page.waitForTimeout(2000);

    // Extract page data
    const pageData = await page.evaluate(() => {
      return {
        title: document.title,
        url: window.location.href,
        viewport: {
          width: window.innerWidth,
          height: window.innerHeight
        },
        scrollHeight: document.documentElement.scrollHeight,
        // Add more data extraction as needed
        headings: Array.from(document.querySelectorAll('h1, h2, h3')).map(h => ({
          tag: h.tagName,
          text: h.textContent.trim()
        })).slice(0, 10)
      };
    });

    console.error(`[INFO] Page title: ${pageData.title}`);
    console.error(`[INFO] Page height: ${pageData.scrollHeight}px`);

    // Take screenshot
    console.error(`[INFO] Capturing screenshot...`);
    await page.screenshot({
      path: screenshotPath,
      fullPage: fullPage,
      type: 'png'
    });

    console.error(`[INFO] Screenshot saved: ${screenshotPath}`);

    // Optional: Extract specific elements
    {{#if extractSelectors}}
    const extractedData = {};
    {{#each extractSelectors}}
    try {
      extractedData.{{camelCase this.name}} = await page.$$eval('{{this.selector}}', elements => {
        return elements.slice(0, {{this.limit}}).map(el => ({
          text: el.textContent.trim(),
          html: el.innerHTML
        }));
      });
    } catch (e) {
      console.error(`[WARN] Could not extract {{this.name}}: ${e.message}`);
      extractedData.{{camelCase this.name}} = [];
    }
    {{/each}}
    {{/if}}

    const duration = Date.now() - startTime;

    // Output structured JSON result
    const result = {
      success: true,
      data: {
        ...pageData,
        {{#if extractSelectors}}
        extracted: extractedData,
        {{/if}}
        screenshotPath: screenshotPath
      },
      metadata: {
        url: page.url(),
        timestamp: new Date().toISOString(),
        duration: duration,
        browser: 'chromium',
        screenshots: [screenshotPath]
      }
    };

    console.log(JSON.stringify(result, null, 2));

  } catch (error) {
    console.error(`[ERROR] ${error.message}`);

    let errorScreenshotPath = null;

    // Take screenshot on error
    if (page) {
      try {
        errorScreenshotPath = path.join(
          config.screenshotDir,
          `error-${Date.now()}.png`
        );
        if (!fs.existsSync(config.screenshotDir)) {
          fs.mkdirSync(config.screenshotDir, { recursive: true });
        }
        await page.screenshot({
          path: errorScreenshotPath,
          fullPage: true
        });
        console.error(`[INFO] Error screenshot saved: ${errorScreenshotPath}`);
      } catch (screenshotError) {
        console.error(`[WARN] Failed to capture screenshot: ${screenshotError.message}`);
      }
    }

    const duration = Date.now() - startTime;

    // Output error as JSON
    const errorResult = {
      success: false,
      data: null,
      metadata: {
        url: page ? page.url() : targetUrl,
        timestamp: new Date().toISOString(),
        duration: duration,
        browser: 'chromium'
      },
      error: {
        message: error.message,
        stack: error.stack,
        screenshot: errorScreenshotPath
      }
    };

    console.log(JSON.stringify(errorResult, null, 2));
    process.exit(1);

  } finally {
    // Cleanup
    if (context) {
      await context.close();
    }
    if (browser) {
      await browser.close();
    }
    console.error('[INFO] Browser closed');
  }
}

// Run main function
main().catch(error => {
  console.error(`[FATAL] ${error.message}`);
  process.exit(1);
});
