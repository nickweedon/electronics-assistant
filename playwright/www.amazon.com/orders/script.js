#!/usr/bin/env node

/**
 * orders - Playwright automation for amazon.com
 * Generated by Playwright skill
 *
 * Parameters:
 *   --maxOrders=N  : Maximum number of orders to retrieve (default: 10)
 *   --year=YYYY    : Filter by year (default: current year)
 *   --manualLogin  : Force manual login even if session exists
 *   --headless=false : Run with visible browser (required for first-time login)
 */

const playwright = require('playwright-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const fs = require('fs');
const path = require('path');
const os = require('os');

// Apply stealth plugin to avoid detection
playwright.chromium.use(StealthPlugin());

// Parse command line arguments
const args = {};
process.argv.slice(2).forEach(arg => {
  const [key, value] = arg.replace('--', '').split('=');
  args[key] = value || 'true';
});

// Configuration
const config = {
  headless: args.headless !== 'false',
  timeout: parseInt(args.timeout) || 15000,
  screenshotOnError: true,
  screenshotDir: './screenshots',
  viewport: { width: 1920, height: 1080 },
  maxOrders: parseInt(args.maxOrders) || 10,
  year: args.year || new Date().getFullYear().toString(),
  manualLogin: args.manualLogin === 'true',
  // Use persistent profile directory
  userDataDir: path.join(os.homedir(), '.cache', 'playwright-profiles', 'amazon')
};

// Ensure screenshot directory exists
if (!fs.existsSync(config.screenshotDir)) {
  fs.mkdirSync(config.screenshotDir, { recursive: true });
}

/**
 * Check if user is logged in to Amazon
 */
async function isLoggedIn(page) {
  try {
    const currentUrl = page.url();

    // If we're on a login page, definitely not logged in
    if (currentUrl.includes('/ap/signin') || currentUrl.includes('/ap/register')) {
      console.error('[DEBUG] On login page - not logged in');
      return false;
    }

    // If we successfully reached the orders page, we're likely logged in
    if (currentUrl.includes('/order-history') || currentUrl.includes('/your-orders')) {
      console.error('[DEBUG] On orders page - checking for order content');
      // Still need to verify we see actual content, not a login redirect
      const hasOrders = await page.$('#ordersContainer, [data-test-id="order-card"], .order-card, .order');
      if (hasOrders) {
        console.error('[DEBUG] Found order content - logged in');
        return true;
      }
      // If we're on the orders URL, even without finding specific selectors, likely logged in
      console.error('[DEBUG] On orders URL - assuming logged in');
      return true;
    }

    // Check for "Hello, Sign in" text (indicates NOT logged in)
    const signInElement = await page.$('text=/Hello, Sign in/i');
    if (signInElement) {
      const isVisible = await signInElement.isVisible();
      if (isVisible) {
        console.error('[DEBUG] Found "Hello, Sign in" - not logged in');
        return false;
      }
    }

    // Look for logged-in indicators
    const loginIndicators = [
      '#nav-link-accountList',  // Account & Lists menu
      'text=/Hello,/i',          // "Hello, [name]" greeting
      '#nav-al-your-account',    // Your Account link
      '[data-nav-ref="nav_youraccount_btn"]'  // Account button
    ];

    for (const selector of loginIndicators) {
      try {
        const element = await page.$(selector);
        if (element) {
          const text = await element.textContent();
          // Make sure it's not "Hello, Sign in" but actually has a name
          if (text && !text.includes('Sign in')) {
            console.error(`[DEBUG] Found login indicator: ${selector} - "${text}"`);
            return true;
          }
        }
      } catch (e) {
        // Continue checking other indicators
      }
    }

    console.error('[DEBUG] No clear login indicators found');
    return false;
  } catch (error) {
    console.error(`[DEBUG] Error checking login status: ${error.message}`);
    return false;
  }
}

/**
 * Extract order data from the orders page
 */
async function extractOrders(page, maxOrders) {
  console.error('[INFO] Extracting order data...');

  // Wait for orders to load
  try {
    await page.waitForSelector('[data-order-id], .order-card, .order', {
      timeout: 10000
    });
  } catch (error) {
    console.error('[WARN] Could not find order elements, page might not have loaded correctly');
  }

  // Give extra time for dynamic content to load
  await page.waitForTimeout(3000);

  // Extract order information
  const orders = await page.evaluate((max) => {
    // Try multiple selectors for order containers
    let orderElements = document.querySelectorAll('.order-card');
    if (orderElements.length === 0) {
      orderElements = document.querySelectorAll('.order');
    }
    if (orderElements.length === 0) {
      orderElements = document.querySelectorAll('[data-order-id]');
    }

    const results = [];

    console.log(`Found ${orderElements.length} order elements`);

    for (let i = 0; i < Math.min(orderElements.length, max); i++) {
      const orderEl = orderElements[i];

      // Extract order ID
      let orderNumber = orderEl.getAttribute('data-order-id') || '';
      if (!orderNumber) {
        const orderIdEl = orderEl.querySelector('[data-order-id]');
        orderNumber = orderIdEl ? orderIdEl.getAttribute('data-order-id') : '';
      }
      if (!orderNumber) {
        // Try to find in text - look more broadly
        const allText = orderEl.textContent;
        const match = allText.match(/Order[#\s]+(\d{3}-\d{7}-\d{7})/i);
        if (match) orderNumber = match[1];
      }

      // Extract order date - look for "Order placed" followed by date
      let orderDate = '';

      // Find "Order placed" text, then look for the date in the next sibling
      const allElements = Array.from(orderEl.querySelectorAll('span, div'));
      for (let i = 0; i < allElements.length; i++) {
        const el = allElements[i];
        const text = el.textContent.trim();
        if (text === 'Order placed' && i + 1 < allElements.length) {
          // Look in next few elements for a date
          for (let j = i + 1; j < Math.min(i + 5, allElements.length); j++) {
            const nextText = allElements[j].textContent.trim();
            const dateMatch = nextText.match(/^(\w+ \d+,?\s*\d{4})$/);
            if (dateMatch) {
              orderDate = dateMatch[1];
              break;
            }
          }
          if (orderDate) break;
        }
      }

      // Extract order total - more comprehensive search
      let orderTotal = '';

      // Look for "Total" label followed by price
      const allSpans = orderEl.querySelectorAll('span, div');
      for (let j = 0; j < allSpans.length; j++) {
        const el = allSpans[j];
        const text = el.textContent.trim();
        if (text.match(/^Total:?\s*\$/) || text.match(/^Order total:?\s*\$/i)) {
          const priceMatch = text.match(/\$[\d.,]+/);
          if (priceMatch) {
            orderTotal = priceMatch[0];
            break;
          }
        }
        // Also check if next sibling has the price
        if (text.toLowerCase() === 'total' && j + 1 < allSpans.length) {
          const nextText = allSpans[j + 1].textContent.trim();
          const priceMatch = nextText.match(/\$[\d.,]+/);
          if (priceMatch) {
            orderTotal = priceMatch[0];
            break;
          }
        }
      }

      // Extract order status
      let orderStatus = '';
      const statusEl = orderEl.querySelector('.shipment-top-row, .delivery-box__primary-text');
      if (statusEl) {
        orderStatus = statusEl.textContent.trim();
      }

      // Extract products - improved selectors
      const products = [];

      // First, collect all images in the order with their URLs
      const imageMap = {};
      const allImages = orderEl.querySelectorAll('img[src*="images/I/"]');
      allImages.forEach(img => {
        const alt = img.getAttribute('alt') || '';
        const src = img.src;
        if (alt && src) {
          imageMap[alt] = src;
        }
      });

      // Find all product links
      const productLinks = orderEl.querySelectorAll('a[href*="/dp/"], a[href*="/gp/product/"]');

      productLinks.forEach(linkEl => {
        // Skip if this is a duplicate (same href already processed)
        const productUrl = linkEl.href;
        if (products.some(p => p.productUrl === productUrl)) {
          return;
        }

        // Product title - get from link text or nearby element
        let title = linkEl.textContent.trim();

        // If title is empty or too short, look for nearby title element
        if (!title || title.length < 10) {
          const nearbyTitle = linkEl.closest('div').querySelector('[class*="product"], [class*="title"]');
          if (nearbyTitle) {
            title = nearbyTitle.textContent.trim();
          }
        }

        // Product image - match from imageMap by title
        let imageUrl = '';
        for (const alt in imageMap) {
          // Check if the image alt text contains part of the title or vice versa
          if (title.includes(alt.substring(0, 30)) || alt.includes(title.substring(0, 30))) {
            imageUrl = imageMap[alt];
            break;
          }
        }

        // If no match found, try to find closest image
        if (!imageUrl) {
          const container = linkEl.closest('.order-card, .order');
          if (container) {
            const nearbyImg = container.querySelector('img[src*="images/I/"]');
            if (nearbyImg) {
              imageUrl = nearbyImg.src;
            }
          }
        }

        // Product price - look in same container
        let price = '';
        const container = linkEl.closest('div');
        if (container) {
          const priceEl = container.querySelector('[class*="price"], .a-color-price');
          if (priceEl) {
            const priceText = priceEl.textContent;
            const priceMatch = priceText.match(/\$[\d.,]+/);
            if (priceMatch) price = priceMatch[0];
          }
        }

        if (title && title.length > 10) {
          products.push({
            title,
            price: price || 'N/A',
            imageUrl: imageUrl || '',
            productUrl
          });
        }
      });

      results.push({
        orderNumber,
        orderDate,
        orderStatus,
        orderTotal: orderTotal || 'N/A',
        products
      });
    }

    return results;
  }, maxOrders);

  return orders;
}

/**
 * Main execution function
 */
async function main() {
  const startTime = Date.now();
  let context = null;
  let page = null;

  try {
    // Launch browser with persistent context for session management
    console.error('[INFO] Launching browser with persistent context and stealth...');
    console.error(`[INFO] User data directory: ${config.userDataDir}`);

    context = await playwright.chromium.launchPersistentContext(config.userDataDir, {
      headless: config.headless,
      viewport: config.viewport,
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
      locale: 'en-US',
      timezoneId: 'America/New_York',
      permissions: [],
      extraHTTPHeaders: {
        'Accept-Language': 'en-US,en;q=0.9'
      },
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-blink-features=AutomationControlled',
        '--disable-session-crashed-bubble',
        '--hide-crash-restore-bubble'
      ]
    });

    page = context.pages()[0] || await context.newPage();
    page.setDefaultTimeout(config.timeout);

    // Navigate to Amazon orders page
    console.error('[INFO] Navigating to Amazon orders page...');
    const ordersUrl = `https://www.amazon.com/gp/your-account/order-history?orderFilter=year-${config.year}`;
    await page.goto(ordersUrl, {
      waitUntil: 'domcontentloaded',
      timeout: config.timeout
    });

    // Give the page time to settle
    await page.waitForTimeout(3000);

    // Check if logged in
    const loggedIn = await isLoggedIn(page);

    if (!loggedIn || config.manualLogin) {
      console.error('[INFO] ‚ö†Ô∏è  NOT LOGGED IN - Manual login required');
      console.error('[INFO] üëâ Please log in to Amazon in the browser window');
      console.error('[INFO] üïê Waiting up to 2 minutes for manual login...');
      console.error('[INFO] ‚ÑπÔ∏è  Script will auto-continue once login is detected');

      // Poll every 5 seconds for up to 2 minutes
      const maxWaitTime = 120000; // 2 minutes
      const pollInterval = 5000;  // 5 seconds
      const startWait = Date.now();
      let nowLoggedIn = false;

      while (Date.now() - startWait < maxWaitTime) {
        await page.waitForTimeout(pollInterval);
        nowLoggedIn = await isLoggedIn(page);
        if (nowLoggedIn) {
          console.error('[INFO] ‚úÖ Login detected!');
          break;
        }
        const elapsed = Math.round((Date.now() - startWait) / 1000);
        console.error(`[INFO] Still waiting... (${elapsed}s elapsed)`);
      }

      if (!nowLoggedIn) {
        throw new Error('Login timeout - please run again with --headless=false to log in');
      }

      // Navigate to orders page again after login
      await page.goto(ordersUrl, {
        waitUntil: 'domcontentloaded',
        timeout: config.timeout
      });
      await page.waitForTimeout(3000);
    } else {
      console.error('[INFO] ‚úÖ Already logged in (using saved session)');
    }

    console.error('[INFO] Page loaded successfully');
    console.error(`[INFO] Current URL: ${page.url()}`);

    // Take screenshot for debugging if needed
    if (args.debug === 'true') {
      const debugScreenshot = path.join(config.screenshotDir, `debug-orders-${Date.now()}.png`);
      await page.screenshot({ path: debugScreenshot, fullPage: true });
      console.error(`[DEBUG] Screenshot saved: ${debugScreenshot}`);

      // Save HTML for debugging
      const html = await page.content();
      const htmlPath = path.join(config.screenshotDir, `debug-orders-${Date.now()}.html`);
      require('fs').writeFileSync(htmlPath, html);
      console.error(`[DEBUG] HTML saved: ${htmlPath}`);
    }

    // Extract orders
    const orders = await extractOrders(page, config.maxOrders);

    console.error(`[INFO] Successfully extracted ${orders.length} orders`);

    const duration = Date.now() - startTime;

    // Output structured JSON result
    const result = {
      success: true,
      data: {
        orders: orders,
        count: orders.length,
        filters: {
          maxOrders: config.maxOrders,
          year: config.year
        }
      },
      metadata: {
        url: page.url(),
        timestamp: new Date().toISOString(),
        duration: duration,
        browser: 'chromium',
        screenshots: [],
        sessionPersisted: true
      }
    };

    console.log(JSON.stringify(result, null, 2));

  } catch (error) {
    console.error(`[ERROR] ${error.message}`);

    let screenshotPath = null;

    // Take screenshot on error
    if (config.screenshotOnError && page) {
      try {
        screenshotPath = path.join(
          config.screenshotDir,
          `error-${Date.now()}.png`
        );
        await page.screenshot({
          path: screenshotPath,
          fullPage: true
        });
        console.error(`[INFO] Error screenshot saved: ${screenshotPath}`);
      } catch (screenshotError) {
        console.error(`[WARN] Failed to capture screenshot: ${screenshotError.message}`);
      }
    }

    const duration = Date.now() - startTime;

    // Output error as JSON
    const errorResult = {
      success: false,
      data: null,
      metadata: {
        url: page ? page.url() : '',
        timestamp: new Date().toISOString(),
        duration: duration,
        browser: 'chromium'
      },
      error: {
        message: error.message,
        stack: error.stack,
        screenshot: screenshotPath
      }
    };

    console.log(JSON.stringify(errorResult, null, 2));
    process.exit(1);

  } finally {
    // Cleanup - close persistent context
    if (context) {
      await context.close();
    }
    console.error('[INFO] Browser closed (session saved)');
  }
}

// Run main function
main().catch(error => {
  console.error(`[FATAL] ${error.message}`);
  process.exit(1);
});
