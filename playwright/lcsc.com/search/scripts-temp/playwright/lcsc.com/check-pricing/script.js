#!/usr/bin/env node

/**
 * {{actionName}} - {{description}}
 * Generated by Playwright skill
 *
 * Parameters:
{{#each parameters}}
 * - {{this.name}}: {{this.description}}{{#if this.default}} (default: {{this.default}}){{/if}}
{{/each}}
 */

const playwright = require('playwright-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const fs = require('fs');
const path = require('path');

// Apply stealth plugin to avoid detection
playwright.chromium.use(StealthPlugin());

// Parse command line arguments
const args = {};
process.argv.slice(2).forEach(arg => {
  const [key, value] = arg.replace('--', '').split('=');
  args[key] = value;
});

{{#each parameters}}
const {{camelCase this.name}} = args.{{camelCase this.name}}{{#if this.default}} || '{{this.default}}'{{/if}};
{{/each}}

// Configuration
const config = {
  headless: args.headless !== 'false',
  timeout: parseInt(args.timeout) || 5000,
  screenshotOnError: true,
  screenshotDir: './screenshots',
  viewport: { width: 1920, height: 1080 }
};

// Ensure screenshot directory exists
if (!fs.existsSync(config.screenshotDir)) {
  fs.mkdirSync(config.screenshotDir, { recursive: true });
}

/**
 * Main execution function
 */
async function main() {
  const startTime = Date.now();
  let browser = null;
  let context = null;
  let page = null;

  try {
    // Launch browser with stealth
    console.error('[INFO] Launching browser...');
    browser = await playwright.chromium.launch({
      headless: config.headless,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-blink-features=AutomationControlled'
      ]
    });

    // Create context with realistic settings
    context = await browser.newContext({
      viewport: config.viewport,
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      locale: 'en-US',
      timezoneId: 'America/New_York',
      permissions: [],
      extraHTTPHeaders: {
        'Accept-Language': 'en-US,en;q=0.9'
      }
    });

    page = await context.newPage();

    // Set default timeout
    page.setDefaultTimeout(config.timeout);

    console.error('[INFO] Navigating to {{url}}...');
    await page.goto('{{url}}', {
      waitUntil: 'domcontentloaded',
      timeout: config.timeout
    });

    // Give the page time to settle
    await page.waitForTimeout(2000);

    console.error('[INFO] Page loaded successfully');

    // ==============================================
    // YOUR CUSTOM LOGIC HERE
    // ==============================================

    {{#if customLogic}}
    {{{customLogic}}}
    {{else}}
    // Example: Extract page title
    const title = await page.title();
    const url = page.url();

    console.error(`[INFO] Page title: ${title}`);

    const data = {
      title,
      url,
      // Add your data extraction here
    };
    {{/if}}

    // ==============================================
    // END CUSTOM LOGIC
    // ==============================================

    const duration = Date.now() - startTime;

    // Output structured JSON result
    const result = {
      success: true,
      data: data,
      metadata: {
        url: page.url(),
        timestamp: new Date().toISOString(),
        duration: duration,
        browser: 'chromium',
        screenshots: []
      }
    };

    console.log(JSON.stringify(result, null, 2));

  } catch (error) {
    console.error(`[ERROR] ${error.message}`);

    let screenshotPath = null;

    // Take screenshot on error
    if (config.screenshotOnError && page) {
      try {
        screenshotPath = path.join(
          config.screenshotDir,
          `error-${Date.now()}.png`
        );
        await page.screenshot({
          path: screenshotPath,
          fullPage: true
        });
        console.error(`[INFO] Error screenshot saved: ${screenshotPath}`);
      } catch (screenshotError) {
        console.error(`[WARN] Failed to capture screenshot: ${screenshotError.message}`);
      }
    }

    const duration = Date.now() - startTime;

    // Output error as JSON
    const errorResult = {
      success: false,
      data: null,
      metadata: {
        url: page ? page.url() : '{{url}}',
        timestamp: new Date().toISOString(),
        duration: duration,
        browser: 'chromium'
      },
      error: {
        message: error.message,
        stack: error.stack,
        screenshot: screenshotPath
      }
    };

    console.log(JSON.stringify(errorResult, null, 2));
    process.exit(1);

  } finally {
    // Cleanup
    if (context) {
      await context.close();
    }
    if (browser) {
      await browser.close();
    }
    console.error('[INFO] Browser closed');
  }
}

// Run main function
main().catch(error => {
  console.error(`[FATAL] ${error.message}`);
  process.exit(1);
});
